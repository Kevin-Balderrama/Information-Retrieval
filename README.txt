How to Compile:
Example copy/paste:
javac SearchEngine.java
java SearchEngine -CorpusDir PathOfDir -InvertedIndex NameOfIndexFile.txt -StopList NameOfStopListFile.txt -Queries QueryFile.txt -Results ResultsFile.txt -UsePorter true -snippetLength 5 -output both

Generic:
javac SearchEngine.java
java SearchEngine 
	-CorpusDir 	PathOfDir 
	-InvertedIndex 	NameOfIndexFile.txt 
	-StopList 	NameOfStopListFile.txt 
	-Queries 	QueryFile.txt 
	-Results 	ResultsFile.txt 
	-UsePorter 	true | false
	-snippetLength 	integer >0
	-output gui|file|both

-CorpusDir (Required input)
	must contain corpus, structured as follows:
	PathOfDir-must be a folder with subfolders:
	PathOfDir/QueryFolder1/
	...
	PathOfDir/QueryFolderN/
	with txt files in each folder as such:
	PathOfDir/QueryFile/fileName1.txt
	...
	PathOfDir/QueryFile/fileNameN.txt
	CorpusDir can be generated by using the included google crawler class, given a text file with queries.
-InvertedIndex (Not Required)
	outputs in following format, if not already exists:
	wordX->[fileNameX.txt wordcountOffset, ..., fileNameY.txt wordcountOffset]
	...
	wordY->[fileNameX.txt wordcountOffset, ..., fileNameY.txt wordcountOffset]
-StopList (Not Required)	
	outputs in following format, if not already exists:
	numberOfOccurences: instance(s) of wordX
	...
	numberOfOccurences: instance(s) of wordY
-Queries  (Required input)	
	required to implement search feature
	input in following format:
	Query <word> | Frequency <word>
	...
	Query <word> | Frequency <word>
-Results  (Not Required)
	output in following format:
	Query <word> | Frequency <word>
	ResultOfQuery

	...
	Query <word> | Frequency <word>
	ResultOfQuery
-UsePorter  (Not Required)
	if enabled, will set flag to use Porter's Algorithm to true
	disabled by default
-snippetLength  (Not Required)
	if given any number >0, will change snippet length before and after word
	0 by default
-output (Not Required)
	gui|file|both
	gui will allow printing to a graphical disaplay of the data
	file will allow printing to a data file
	both will allow for display to gui and printing to a data file

Sample Files included, compiled perfectly fine on my own machine and gave output.

UserManual includes screenshots of GUI
	-loading bar is to indicate that something is happening rather than a static screen
	-data display presents all returned items when enabled

Input
	-QueryFile
Output
	-data.txt		[generated for output of recall and precision, and then results of query]
	-NameOfIndexFile.txt	[generated index file, mapping of words to where they appear, by doc# and word count]
	-NameOfStopListFile.txt	[contains about top 50 or a smaller size of most frequent words as they are less important]
	-PorterIndex.txt	[similar to above index file, however words are instead roots]
	-ResultsFile.txt	[contains result of all queries typed]
	-snippets.txt		[contains first result's snippets only, by replacing while loop for an if statement, otherwise, would take minutes to complete.]
				Note can be easily modified, swap if for while(comment where applicable) to process all result's snippets


Recall and precision were difficult to implement considering queries were only 2 words, so I used total number of instances in a given hashmap as follows
TP - total number of results returned to user
TP + FP- all documents that match and don't match, (corpus)
P- all documents that objectively match, (invertedIndex)



